#!/usr/bin/python
import sys
import os
import tempfile
import time
import shutil

STARTUP_DIR=sys.path[0]

#sys.path.append(os.path.join(STARTUP_DIR,".."))
#sys.path.append(os.path.join(STARTUP_DIR,"../../lib"))
# get source dir from env var until we push upstream to glideinWMS
if 'GLIDEIN_SRC_DIR' in os.environ:
    sys.path.append(os.path.join(os.environ['GLIDEIN_SRC_DIR'], "factory"))
    sys.path.append(os.path.join(os.environ['GLIDEIN_SRC_DIR'], "lib"))
else:
    print '"GLIDEIN_SRC_DIR" not defined. exiting.'
    sys.exit(1)

import condorManager
import glideFactoryConfig
import condorLogParser
import condorPrivsep
import condorExe
import glideFactoryLib

#globals
# statuses of lost connections
lost_con_stats=('020','026','022','010','029')
verbose = False

'''def createSubmitFile(sfile,log_dir,
                     script_file, timeout, grid_type, gatekeeper):
    fd=open(sfile,"w")
    try:
        fd.write("universe=grid\n")
        fd.write("grid_resource=%s %s\n" % (grid_type, gatekeeper))
        fd.write("executable=%s\n"%script_file)
        fd.write("copy_to_spool=True\n")
        fd.write("output=%s\n"%os.path.join(log_dir,"testpilot.$(Cluster).$(Process).out"))
        fd.write("error=%s\n"%os.path.join(log_dir,"testpilot.$(Cluster).$(Process).err"))
        fd.write("log=%s\n"%os.path.join(log_dir,"testpilot.$(Cluster).$(Process).log"))
        fd.write("transfer_executable=True\n")
        fd.write("when_to_transfer_output=ON_EXIT\n")
        fd.write("notification=Never\n")
        #fd.write("periodic_remove=(CurrentTime>%li)\n"%(long(time.time())+timeout+30)) # karakiri after timeout+delta
        fd.write("stream_output=False\n")
        fd.write("stream_error=False\n")
        fd.write("queue\n")
    finally:
        fd.close()
'''

def create_submit_file(sub_file, script_file, glide_desc, job_desc, user):
    log_dir = "%s/user_%s/glidein_%s/test" % (glide_desc.data['ClientLogBaseDir'],user,glide_desc.data['GlideinName'])
    ent_name = job_desc.data['EntryName']
    grid_type = job_desc.data['GridType']
    # consider later case where we want fork instead
    gatekeeper = job_desc.data['Gatekeeper']
    rsl = None
    if 'GlobusRSL' in job_desc.data:
        rsl = job_desc.data['GlobusRSL']
    fd=open(sub_file,"w")
    try:
        fd.write("universe=grid\n")
        fd.write("grid_resource=%s %s\n" % (grid_type, gatekeeper))
        if rsl is not None:
            fd.write("globus_rsl=%s\n" % rsl)
        fd.write("executable=%s\n"%script_file)
        fd.write("copy_to_spool=True\n")
        fd.write("output=%s\n"%os.path.join(log_dir,"testpilot_%s.$(Cluster).$(Process).out" % ent_name))
        fd.write("error=%s\n"%os.path.join(log_dir,"testpilot_%s.$(Cluster).$(Process).err" % ent_name))
        fd.write("log=%s\n"%os.path.join(log_dir,"testpilot_%s.log" % ent_name))
        fd.write("transfer_executable=True\n")
        fd.write("when_to_transfer_output=ON_EXIT\n")
        fd.write("notification=Never\n")
        #fd.write("periodic_remove=(CurrentTime>%li)\n"%(long(time.time())+timeout+30)) # karakiri after timeout+delta
        fd.write("stream_output=False\n")
        fd.write("stream_error=False\n")
        fd.write("queue\n")
    finally:
        fd.close()

def createScript(sfile):
    try:
        fd = open(sfile, "w")
        fd.write("#!/bin/sh\n")
        fd.write("whoami\n")
        #fd.write("sleep 600\n")
        #fd.write('echo Done > $PWD/job.done\n')
    finally:
        fd.close()

# returns tuple (True | False,status,message) True if job does not require removal (terminated or aborted) 
def checkFile(fname,schedd_name, timeout):
    interval = 5
    deadline=time.time()+timeout
    ptime = -1 # force the file to be read the first time
    while True:
        mtime = os.path.getmtime(fname)

        if mtime > ptime:
            status,message = getLastLogStatus(fname)
            if verbose:
                print message
            # terminated or aborted
            if status == '005' or status == '009':
                return (True, status, message)
            # failed to submit, held, or connection lost
            elif status == '018' or status == '012' or status in lost_con_stats:
                return (False, status, message)

        time.sleep(interval)

        if time.time() > deadline:
            break
        
        ptime = mtime

    raise RuntimeError, "Command did not reply within timeout (%ss)"%timeout

def printFile(fname,outfd):
    fd=open(fname)
    try:
        data=fd.read()
        outfd.write(data)
    finally:
        fd.close()

def getLastLogStatus(fname):
    fin = open(fname)
    
    lines = fin.readlines()
    fin.close()

    # could i have done a for loop with negatives instead?
    cur = len(lines)-1
    end = -1
    start = -1
    while cur >= 0:
        if lines[cur].startswith('...'):
            end = cur
        elif lines[cur][:3].isdigit():
            start = cur
            status = lines[cur][:3]
            break
        cur -= 1

    # if can't find status number throw error
    if start == -1:
        raise RuntimeError, "Error retrieving status in:%s" % fname

    # if couldn't find '...' string just print to eof
    if end == -1:
        end = len(lines)-1
        
    # could i have done a for loop with negatives instead?
    message = ""
    for i in range(start,end+1):
        message += lines[i]
    
    message = message.rstrip()
    return status,message

# should we ever attempt without privsep like glidein does?
def privSubmit(username, schedd_name, sub_file, x509_proxy_fname):
    cond_sub_path = condorExe.iexe_cmd("which condor_submit")[0][:-1]
    exe_env=['X509_USER_PROXY=%s'%x509_proxy_fname]
    for var in os.environ.keys():
                        if ((var in ('PATH','LD_LIBRARY_PATH','X509_CERT_DIR')) or
                            (var[:8]=='_CONDOR_') or (var[:7]=='CONDOR_')):
                            if os.environ.has_key(var):
                                exe_env.append('%s=%s'%(var,os.environ[var]))

    if schedd_name is None:
        submit_out=condorPrivsep.execute(username,".",cond_sub_path,[cond_sub_path,sub_file],exe_env)
    else:
        submit_out=condorPrivsep.execute(username,".",cond_sub_path,[cond_sub_path,'-name',schedd_name,sub_file],exe_env)
    cluster,count=glideFactoryLib.extractJobId(submit_out)
    return cluster

# what if user / entry create invalid path?
'''def getLogDir(user, entry):
    glide_conf = glideFactoryConfig.GlideinDescript()
    return os.path.join(glide_conf.data['ClientLogBaseDir'],"user_%s/glidein_%s/entry_%s"
        % (user, glide_conf.data['GlideinName'],entry))
'''

def get_proxy_dir(glide_desc, job_desc, user):
    return "%s/user_%s/glidein_%s/entry_%s" %(glide_desc.data['ClientProxiesBaseDir'],user,
        glide_desc.data['GlideinName'],job_desc.data['EntryName'])

# return list of proxies
def proxy_ls(user, proxy_dir):
    out = condorPrivsep.execute(user,'.','/bin/ls',['/bin/ls',proxy_dir])
    # strip away newline chars
    return [i[:-1] for i in out]

# return long list of proxies; time sorted
def proxy_lslt(user, proxy_dir):
    out = condorPrivsep.execute(user,'.','/bin/ls',['/bin/ls', '-lt', proxy_dir])
    # strip away newline chars
    return [i[:-1] for i in out]

def get_proxy_life(user, proxy_file):
    try:
        voms_path=condorExe.iexe_cmd("which voms-proxy-info")[0][:-1]
    except:
        print "ERROR: voms-proxy-info not found, but needed"
        return 1

    env=[]
    for k in os.environ.keys():
       env.append('%s=%s'%(k,os.environ[k]))

    out = condorPrivsep.execute(user,'.',voms_path,[voms_path, '-dont-verify-ac', '-timeleft', '-file', proxy_file],env)
    return int(out[0][:-1])

if __name__ == "__main__":
    user = sys.argv[-3]
    entry = sys.argv[-2]
    proxy = sys.argv[-1]
    

    if '-t' in sys.argv:
        timeout = int(sys.argv[sys.argv.index('-t')+1])
    else:
        timeout = 300

    if '-v' in sys.argv:
        verbose = True

    glide_desc = glideFactoryConfig.GlideinDescript()
    job_desc = glideFactoryConfig.JobDescript(entry)

    proxy_dir = get_proxy_dir(glide_desc, job_desc, user)
    print proxy_dir
    out = proxy_lslt(user, proxy_dir)

    #for p in proxies:
    #    if not p.endswith('.old'):
    #        print "%s Seconds Left: %s" % (p, get_proxy_life(user, "%s/%s" % (proxy_dir, p)))

    count = 0
    proxies = []
    for line in out:
        if not line.endswith('.old'):
            proxies.append(line.split()[9])
            print "[%s] %s" % (count,line)
            count += 1
    print proxies
    
    #schedd_name=job_desc.data['Schedd']
    '''schedd_name=None
    
    tmpdir = tempfile.mkdtemp(prefix="testpilot_")

    try:
        os.chmod(tmpdir, 0755)
        sub_file = os.path.join(tmpdir, "job.condor")
        script_file = os.path.join(tmpdir, "testpilot.sh")
        user_dir = "%s/user_%s/glidein_%s" % (glide_desc.data['ClientLogBaseDir'],user,glide_desc.data['GlideinName'])
        if not os.path.exists("%s/test" % user_dir):
            condorPrivsep.execute(user,user_dir,'/bin/mkdir',['/bin/mkdir','test'])

        createScript(script_file)
        #createSubmitFile(sub_file, log_dir, script_file, timeout, grid_type, gatekeeper)
        create_submit_file(sub_file, script_file, glide_desc, job_desc, user)
        
        privSubmit(user, schedd_name, sub_file, proxy)
        
    finally:
        shutil.rmtree(tmpdir)
    '''
