#!/usr/bin/env python2.6

import calendar
import copy
import json
import os
import optparse
import pytz
import random
import re
import sys
import getpass
import smtplib
import socket
import subprocess as sp
import StringIO
import time
from email.mime.text import MIMEText
from datetime import datetime, timedelta

import tzlocal as tzl
from dateutil.tz import tzutc
from dateutil.parser import parse as parse_timestamp
from xmltodict import parse as xml_to_dict
from get_grid_downtimes import get_egi, get_osg
import PyRSS2Gen as rssgen

descriptors = {'manual': "Manually registered downtimes",
               'new': "Newly advertised downtimes",
               'none': "Entries without registered nor advertised downtimes",
               'ongoing': "Ongoing downtimes already registered in this factory",
               'removable': "Registered downtimes that have finished and can be removed" }

downtimes_file_path = os.getenv('GLIDEIN_FACTORY_DIR') + "/glideinWMS.downtimes"
rss_file = "rss_downtimes.xml"
rss_path = os.getenv('GLIDEIN_FACTORY_DIR') + '/' + rss_file
rss_url = os.getenv('GLIDEIN_MON_URL') + rss_file
downtimes_cache_file = "/tmp/.downtimes.cache"

def main():

    entries_spec, status_list, options = parse_command_line()

    entries = gather_entries(entries_spec)
    downtimes = get_downtimes(downtimes_cache_file, 60, options.override)
    records = build_records(entries, downtimes)
    commands = gather_commands(records)

    report_s = report_status(records, status_list)
    report_c = report_commands(commands, options.oneline)

    if report_s:
        report = report_s + '\n' + report_c

        print report
        send_report_email(report, options.ask, options.send)

        if commands:
            execute_commands(commands)

    if options.rss:
        generate_feed( records, rss_path, rss_url)

    return 0

def parse_command_line():

    desc = "Checks GOCDB and OIM for advertised downtimes that are currently not registered on this GlideinWMS factory."

    parser = optparse.OptionParser (description=desc)
    parser.add_option ('-s', '--send', action='store_true', default=False,
                       help="If present, sends the report without asking.")
    parser.add_option ('-a', '--ask', action='store_true', default=False,
                       help="If present, does whether to send email.")
    parser.add_option ('-v', '--verbose', action='store_true', default=False,
                       help="If present, displays even the entries not currently advertised as in downtime.")
    parser.add_option ('-u', '--updates', action='store_true', default=False,
                       help="If present, displays only recent downtime events.")
    parser.add_option ('-r', '--rss', action='store_true', default=False,
                       help="If present, generates an RSS feed file to {0}.".format(rss_path))
    parser.add_option ('-l', '--one-line', dest="oneline", action='store_true', default=False,
                       help="If present, prints all suggested commands in a single line, separated by colons.")
    parser.add_option ('-f', '--force-reload', dest="override", action='store_true', default=False,
                       help="If present, overrides the current cache with new data from GOCDB and OIM.")

    options, args = parser.parse_args()

    if args:
        entries_spec = args
    else:
        entries_spec = ['all']

    if options.updates:
        status_list = ['new', 'removable']
    else:
        status_list = descriptors.keys()
        if not options.verbose:
            status_list.remove('none')

    return entries_spec, set(status_list), options

def gather_entries (entries_spec):

    factory_config_file = os.path.join( os.getenv('GLIDEIN_FACTORY_DIR'), "glideinWMS.xml")

    factory_config = xml_to_dict( open( factory_config_file))
    factory_entries = filter( lambda e: e['@enabled'] == 'True',
                              factory_config['glidein']['entries']['entry'] )

    if entries_spec[0].lower() in ('*', 'all'):
        the_entries = factory_entries
    else:
        the_entries = sum( [ filter( lambda e: spec.lower() in e['@name'].lower(), factory_entries )
                            for spec in entries_spec ], [] )
    if not the_entries:
        raise ValueError("Error: There are no configured entries with the specified name")

    return the_entries

def get_downtimes (downtimes_cache_file, cache_expiry=0, force_reload=False):

    now = datetime.utcnow()
    do_get = True
    cache_exists = os.path.exists(downtimes_cache_file)

    if not force_reload and cache_expiry > 0 and cache_exists:
        cache_data_raw = open(downtimes_cache_file, 'r').read()
        cache_data = DateTimeAwareDecoder().decode(cache_data_raw)
        cache_timestamp = cache_data['timestamp']
        age = (now - cache_timestamp).seconds
        if age <= cache_expiry:
            downtimes = cache_data['downtimes']
            do_get = False
            print "Using cached downtimes data (lifetime = %d s, remaining = %d s)" % (cache_expiry, cache_expiry-age)

    if do_get or force_reload:
        downtimes = {"EGI": get_egi(),
                     "OSG": get_osg()}
        cache_timestamp = now

    cache = {'timestamp': cache_timestamp,
             'downtimes': downtimes}

    json_str = DateTimeAwareEncoder().encode(cache)
    json_out = open(downtimes_cache_file, 'w')
    json_out.write(json_str)
    json_out.close()

    return downtimes

def build_records (entries_config, downtimes):

    records = {}

    for entry in entries_config:

        entry_name = entry['@name']

        compute_element = entry['@gatekeeper'].split(':')[0]
        target_hosts = {"CE": compute_element}

        storage_element_attrs = filter( lambda e: e['@name'] == 'GLIDEIN_SEs',
                                        entry['attrs']['attr'] )
        if storage_element_attrs:
            storage_element = storage_element_attrs[0]['@value']
            target_hosts["SE"] = storage_element

        advertisement = get_downtime( entry_name, target_hosts, downtimes )
        registered, manual, comment = is_entry_in_factory_downtime( entry_name)
        key, data = assign_record( advertisement, entry_name, registered, manual,
                                   comment)

        if key not in records:
            records[key] = {}
        records[key][entry_name] = data

    return records

def assign_record (advertisement, entry_name, registered, manual, comment):

    if advertisement is None:
        if registered:
            if manual:
                key, data = 'manual', {'complement': comment.strip('#; ')}
            else:
                command = gen_downtime_command( advertisement, entry_name)
                key, data = 'removable', {'complement': '',
                                          'command': command}
        else:
            key, data = 'none', {'complement': ''}
    else:
        if registered:
            key, data = 'ongoing', {'complement': ''}
        else:
            text = gen_downtime_message(advertisement, entry_name)
            command = gen_downtime_command( advertisement, entry_name)
            key, data = 'new', {'complement': text,
                                'command': command}
        if not manual:
            host, downtime_ad = dictpeek(advertisement)
            if host:
                data['url'] = advertisement[host]['url']

    return key, data

def report_status (records, status_list):

    lines = []
    with_commands = {}
    there_are_commands = False
    indentation_step = 3
    indent = 0

    all_keys = set(records.keys())
    empty_keys = set( filter_dict( lambda key, val: not val, records).keys() )
    included_keys = status_list & (all_keys - empty_keys)

    sorter = lambda r: r[0]

    for status in sorted(included_keys):

        if records[status]:

            lines.append( "* " + descriptors[status] + ":")
            width = max( [ len(entry) for entry in records[status].keys() ] )

            for entry_name, record in sorted(records[status].items(), key=sorter):

                complement = record['complement']
                if complement:
                    if len(complement.splitlines()) > 1:
                        line = indent_multilines(entry_name,
                                                 indent + indentation_step)
                        lines.append('')
                        lines.append(line + ':')
                        line = record['complement']
                        lines.append( indent_multilines( line, indent + 2*indentation_step))
                    else:
                        line = "{0:<{width}} : {1}".format(entry_name, complement, width=width)
                        lines.append( indent_multilines( line, indent + indentation_step))
                else:
                    line = indent_multilines(entry_name, indent + indentation_step)
                    lines.append(line)

            lines.append('')

    return '\n'.join(lines)

def report_commands (commands={}, one_line=False):

    lines = []

    if commands:

        sorter = lambda r: r[0]

        lines.append("---- ---- ----")
        lines.append("Suggested list of downtime commands:\n")

        single_line = []

        for status in commands.keys():
            if one_line:
                for entry_name, record in sorted(commands[status].items(), key=sorter):
                    single_line.append(record['command'])

            else:
                for entry_name, record in sorted(commands[status].items(), key=sorter):
                    lines.append(record['command'])

                if commands[status]:
                    lines.append('')

        if one_line:
            lines.append( '; '.join(single_line) )

    return '\n'.join(lines)

def send_report_email (report, do_ask, do_send):

    subject = "New entry downtimes updates."

    if do_send or ( do_ask and console_prompt("Do you want to send the report?") ):
        to = 'osg-gfactory-reports@physics.ucsd.edu'
        send_email_plain(subject, report, to)
        print "Report sent."

def get_downtime (entry_name, target_hosts, downtimes):

    for federation, records in downtimes.iteritems():
        for host_type, host_name in target_hosts.iteritems():

            record = filter_dict( lambda key, val: key == host_name, records)
            if record:
                record[host_name]['federation'] = federation
                record[host_name]['host_type'] = host_type

                description = record[host_name]['description']
                description = description.replace('"', "'")
                record[host_name]['description'] = description

                return record

    return None

def gen_downtime_message (downtime_record, entry_name):

    if downtime_record:
        hostname, record = dictpeek(downtime_record)
        description = ' '.join(record['description'].split())

        lines = []
        lines.append( "%14s: %s" % ("Federation", record['federation']) )
        lines.append( "%14s: %s (%s)" % ("Affected Host", hostname, record['host_type']) )
        lines.append( "%14s: %s" % ("Description", description) )
        lines.append( "%14s: %s" % ("Start time", print_local_dt( record['start'])) )
        lines.append( "%14s: %s" % ("End time", print_local_dt( record['end'])) )
        message = '\n'.join(lines)

    else:
        message = "%s : This entry is NOT under downtime." % entry_name

    return message

def gen_downtime_command (downtime_record, entry_name):

    if downtime_record:
        downtime_line = "{start}{s: <5s}{end}{s: <5s}{entry}{s: <2s}All{s: <18s}All{s: <18s}# _ad_ {comment}"
        command_body = ( """echo "{line}" >> $GLIDEIN_FACTORY_DIR/glideinWMS.downtimes; """
                         """entry_rm {entry} -const "jobstatus!=2" """)

        hostname, record = dictpeek(downtime_record)

        start_time = record['start'].isoformat()
        end_time = record['end'].isoformat()
        comment = ' '.join( line.strip() for line in record['description'].splitlines() )

        line = downtime_line.format( start = start_time, end = end_time,
                                      entry = entry_name, comment = comment, s = '' )
        command = command_body.format(line = line, entry = entry_name)

    else:
        command = "$GLIDEIN_FACTORY_DIR/factory_startup up -entry {entry}".format(entry=entry_name)

    return command

def is_entry_in_factory_downtime (entry_name, when=datetime.now(tzutc())):

    registered = False
    manual = False
    comment = ''

    record_lines = []
    with open(downtimes_file_path) as fd:
        for line in fd:
            if not line.startswith('#'):           # comments start with a hash
                match = re.search(r'\b' + entry_name + r'\b',
                                  line)                     # whole-word search
                if match:
                    record_lines.append(line.strip())

    for line in record_lines:
        fields = line.split()

        start = parse_timestamp(fields[0])

        if fields[1] != 'None':
            end = parse_timestamp(fields[1])
        else:
            end = None

        entry = fields[2]         # It is equal to entry_name by construction
        frontend = fields[3]
        sec_clas = fields[4]
        comment = ' '.join(fields[5:])

        if when >= start and (end is None or end > when):
            registered = True
            manual = "_ad_" not in comment.lower()
            break

    return registered, manual, comment

def get_local_dt (utc_dt):
    local_tz = tzl.get_localzone()

    return local_tz.normalize( utc_dt.astimezone( local_tz))

def print_local_dt (utc_dt):

    local_dt = get_local_dt( utc_dt)
    return local_dt.strftime( "%B %d, %Y %H:%M %Z%z")

def filter_dict (test_function, dictionary):

   key_function = lambda e: test_function(e[0], e[1])
   return copy.deepcopy (dict (filter (key_function, dictionary.iteritems())))

def get_user_and_host_names():

    user = getpass.getuser()
    host = socket.gethostname()
    return user, host

def send_email_plain (subject, message, to):

    user, host = get_user_and_host_names()
    sender = '%s@%s' % (user, host)

    if isinstance(to, str):
        receivers = to.split(',')
    elif isinstance(to, list):
        receivers = to

    msg = MIMEText (message)

    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = ", ".join(receivers)

    try:
       smtpObj = smtplib.SMTP('localhost')
       smtpObj.sendmail (sender, receivers, msg.as_string())
       print "Successfully sent email to:", ', '.join(receivers)

    except smtplib.SMTPException:
       print "Error: unable to send email"

def indent_multilines (the_string, indent=0, sub_indent=0):

    # splitlines() takes care of all types of line-ending characters
    lines = the_string.splitlines()
    full_indent = indent + sub_indent

    if sub_indent > 0 and len(lines) > 1:
        line_list = [(' '*indent + lines[0])]
        line_list.extend ([ (' '*full_indent + line) for line in lines[1:] ])
    else:
        line_list = [ (' '*indent + line) for line in lines ]

    return '\n'.join(line_list)

def gather_commands (records):

    with_commands = {}

    status_list = set(['new', 'removable'])
    all_keys = set(records.keys())
    empty_keys = set( filter_dict( lambda key, val: not val, records).keys() )
    included_keys = status_list & (all_keys - empty_keys)

    cmd_tester = lambda key, rec: 'command' in rec

    for status in included_keys:
        if records[status]:
            with_commands[status] = filter_dict( cmd_tester, records[status] )

    return with_commands

def execute_commands (commands):

    command_list = []
    for sites in commands.values():
        for site in sites.values():
            command_list.extend( site['command'].split("; ") )

    additions_test = lambda l: 'echo' in l and 'glideinWMS.downtimes' in l
    additions = filter(additions_test, command_list)
    remaining = filter(lambda l: not additions_test(l), command_list)

    downtimes_file = open(downtimes_file_path, 'a')
    for addition in additions:
        to_add = addition.split('"')[1]
        downtimes_file.write(to_add + '\n')
    downtimes_file.close()

    for command in remaining:
        p = sp.Popen(command.split(), stdout=sp.PIPE)
        out, err = p.communicate()
        time.sleep(0.1)

    send_email_plain( 'Executed commands', '\n'.join(additions+remaining),
                      'luis.linares@cern.ch' )

def generate_feed (commands, rss_file_path, rss_url):

    feed = DowntimesFeed(rss_file_path, rss_url)

    for status, records in commands.items():
        for entry_name, record in records.items():
            feed.add_record( entry_name, record, status)

    feed.write()

class DowntimesFeed(object):

    def __init__ (self, rss_file_path, rss_url):

        self.filename = rss_file_path
        self.rss = rssgen.RSS2(
            title = "GlideinWMS Factory Downtimes Advertisements",
            link = rss_url,
            description = "List of recently advertised entry (queue) downtimes, "
            "obtained from GOCDB and OIM.",
            lastBuildDate = datetime.utcnow(),
            items = [])

    def add_record (self, entry_name, record, status):

        text = self.format_description( record['complement'],
                                        record['command'] )
        url = record['url'] if 'url' in record else ''
        guid = entry_name + '-' + url

        self.rss.items.append( rssgen.FlexRSSItem(
                title = "{0} downtime for {1}".format(status.capitalize(),
                                                      entry_name),
                link = url if url else None,
                guid = rssgen.Guid(guid, isPermaLink = False),
                pubDate = datetime.utcnow(),
                description = text )
            )

    def format_description (self, complement, commands):

        lines = []

        info = [ "<b>{0}</b>: {1}<br>".format(*l.split(':', 1))
                for l in complement.strip().splitlines() ]
        if info:
            lines.append("<p>")
            lines.extend(info)
            lines.append("</p>")

        lines.append("<p>Suggested commands:</p>")
        lines.append("<pre>")
        lines.append(commands)
        lines.append("</pre>")

        return ''.join(lines)

    def write (self):
        self.rss.write_xml( open( self.filename, "w"))

def dictpeek (dictionary):

    if isinstance(dictionary, dict):
        if dictionary:
            key, record = dictionary.popitem()
            dictionary[key] = record
            return key, record

    return None, None

def datetime_to_UTC_epoch (dt):

    return calendar.timegm( dt.utctimetuple())

class DateTimeAwareEncoder (json.JSONEncoder):

    def default (self, obj):

        if isinstance(obj, datetime):
            epoch = datetime_to_UTC_epoch(obj)
            encoded_object = { "__type__": "datetime",
                               "epoch": epoch }
        else:
            encoded_object = json.JSONEncoder.default(self, obj)

        return encoded_object

class DateTimeAwareDecoder (json.JSONDecoder):

    def __init__(self):

        json.JSONDecoder.__init__(self, object_hook=self.dict_to_object)

    def dict_to_object(self, d):

        if '__type__' not in d:
            return d

        type = d.pop('__type__')

        if type == 'datetime':
            return datetime.utcfromtimestamp(d["epoch"])
        else:
            return d

def console_prompt (message):

    prompt = raw_input(message.rstrip() + ' ')
    return prompt.lower() in ("y", "ye", "yes", "ok")

if __name__ == "__main__":
    sys.exit (main())

