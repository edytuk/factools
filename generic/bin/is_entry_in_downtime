#!/usr/bin/env python2.6

import copy
import os
import sys
import pytz
from datetime import datetime

import tzlocal as tzl
from dateutil.tz import tzutc
from dateutil.parser import parse as parse_timestamp
from xmltodict import parse as xml_to_dict
from get_grid_downtimes import get_egi, get_osg

def main():

    if len(sys.argv) < 2:
        print "Usage: %s entry_name [entry_name, ...]" % os.path.basename(sys.argv[0])
        return 1

    entry_names_specs = sys.argv[1:]

    factory_config_file = os.path.join( os.getenv('GLIDEIN_FACTORY_DIR'), "glideinWMS.xml")

    factory_config = xml_to_dict( open( factory_config_file))
    factory_entries = filter( lambda e: e['@enabled'] == 'True',
                              factory_config['glidein']['entries']['entry'] )
    the_entries = sum( [ filter( lambda e: spec in e['@name'], factory_entries )
                         for spec in entry_names_specs ], [] )

    if not the_entries:
        print "Error: There are no configured entries with the specified name"
        return 2

    downtimes = {"EGI": get_egi(), "OSG": get_osg()}
    report = {'downtimes':{}, 'no downtimes':{}}

    for entry in the_entries:

        entry_name = entry['@name']

        compute_element = entry['@gatekeeper'].split(':')[0]
        target_hosts = {"CE": compute_element}

        storage_element_attrs = filter( lambda e: e['@name'] == 'GLIDEIN_SEs',
                                        entry['attrs']['attr'] )
        if storage_element_attrs:
            storage_element = storage_element_attrs[0]['@value']
            target_hosts["SE"] = storage_element

        record = get_downtime( entry_name, target_hosts, downtimes )

        if record or entry_name not in report:
            text = gen_downtime_message( record, entry_name)
            if 'is NOT' in text.splitlines()[0]:
                report['no downtimes'][entry_name] = text
            else:
                if not is_entry_in_factory_downtime(entry_name):
                    report['downtimes'][entry_name] = {'text': text}

                    command = gen_downtime_command( record, entry_name)
                    report['downtimes'][entry_name]['command'] = command

    for entry_name, record in sorted(report['no downtimes'].iteritems()):
        print record

    for entry_name, record in sorted(report['downtimes'].iteritems()):
        print record['text']

    print "---- ---- ----"
    print "Suggested list of downtime commands:", '\n'
    for entry_name, record in sorted(report['downtimes'].iteritems()):
        print record['command']

    return 0

def get_downtime (entry_name, target_hosts, downtimes):

    for federation, records in downtimes.iteritems():
        for host_type, host_name in target_hosts.iteritems():

            record = filter_dict( lambda key, val: key == host_name, records)
            if record:
                record[host_name]['federation'] = federation
                record[host_name]['host_type'] = host_type
                return record

    return None

def gen_downtime_message (downtime_record, entry_name):

    if downtime_record:
        hostname, record = downtime_record.popitem()
        downtime_record[hostname] = record

        message = "%s : This entry IS under downtime:\n" % entry_name
        message += "    Federation: " + record['federation'] + '\n'
        message += " Affected Host: %s (%s)\n" % (hostname, record['host_type'])
        message += "   Description: " + record['description'] + '\n'
        message += "    Start time: " + print_local_dt( record['start']) + '\n'
        message += "      End time: " + print_local_dt( record['end']) + '\n'

    else:
        message = "%s : This entry is NOT under downtime:\n" % entry_name

    return message

def gen_downtime_command (downtime_record, entry_name):

    command_body = """{facdir}/factory_startup down -entry {entry} -comment "{comment}"; echo 'wall "check {entry} downtime"' | at {endtime} """
    factory_dir = os.getenv('GLIDEIN_FACTORY_DIR')
    hostname, record = downtime_record.popitem()

    end_time = get_local_dt( record['end'])
    end_time_str = end_time.strftime( "%H:%M %b %d %Y")
    comment = record['description']

    return command_body.format( facdir = factory_dir, entry = entry_name,
                                comment = comment, endtime = end_time_str )

def is_entry_in_factory_downtime (entry_name, when=datetime.now(tzutc())):

    downtimes_file = os.getenv('GLIDEIN_FACTORY_DIR') + "/glideinWMS.downtimes"

    record_lines = []
    with open(downtimes_file) as fd:
        for line in fd:
            if entry_name in line and not line.startswith('#'):
                record_lines.append(line.strip())

    for line in record_lines:
        fields = line.split()

        start = parse_timestamp(fields[0])

        if fields[1] != 'None':
            end = parse_timestamp(fields[1])
        else:
            end = None

        entry = fields[2] # It's equal to entry_name by construction
        frontend = fields[3]
        sec_clas = fields[4]
        comment = ' '.join(fields[5:])

        if when >= start and (end is None or end > when):
            return True

    return False

def get_local_dt (utc_dt):
    local_tz = tzl.get_localzone()

    return local_tz.normalize( utc_dt.astimezone( local_tz))

def print_local_dt (utc_dt):

    local_dt = get_local_dt( utc_dt)
    return local_dt.strftime( "%B %d, %Y %H:%M %Z%z")

def filter_dict (test_function, dictionary):

   key_function = lambda e: test_function(e[0], e[1])
   return copy.deepcopy (dict (filter (key_function, dictionary.iteritems())))


if __name__ == "__main__":
    sys.exit (main())

