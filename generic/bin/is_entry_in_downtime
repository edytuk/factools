#!/usr/bin/env python2.6

import copy
import os
import optparse
import pytz
import sys
import getpass
import smtplib
import socket
from email.mime.text import MIMEText
from datetime import datetime

import tzlocal as tzl
from dateutil.tz import tzutc
from dateutil.parser import parse as parse_timestamp
from xmltodict import parse as xml_to_dict
from get_grid_downtimes import get_egi, get_osg


def main():

    options, args = parse_command_line()
    if args:
        entry_names_specs = args
    else:
        entry_names_specs = ['all']

    entries = gather_entries( entry_names_specs)
    records = build_records( entries)
    report = generate_report( records)

    print report

    subject = "New entry downtimes updates."
    if options.send:
        send_email_plain( subject, report)
    else:
        if options.ask:
            do_send = raw_input ("Do you want to send the report? ")
            if do_send.lower() in ("y", "ye", "yes", "ok"):
                send_email_plain( subject, report)
            else:
                print "Report not sent."

    return 0

def parse_command_line():

    desc = "Checks GOCDB and OIM for advertised downtimes that are currently not registered on this GlideinWMS factory."

    parser = optparse.OptionParser (description=desc)
    parser.add_option ('-s', '--send', action='store_true', default=False,
                       help="If present, sends the report without asking.")
    parser.add_option ('-a', '--ask', action='store_true', default=False,
                       help="If present, does whether to send email.")

    return parser.parse_args()

def gather_entries (entry_names_specs):

    factory_config_file = os.path.join( os.getenv('GLIDEIN_FACTORY_DIR'), "glideinWMS.xml")

    factory_config = xml_to_dict( open( factory_config_file))
    factory_entries = filter( lambda e: e['@enabled'] == 'True',
                              factory_config['glidein']['entries']['entry'] )

    if entry_names_specs[0].lower() in ('*', 'all'):
        the_entries = factory_entries
    else:
        the_entries = sum( [ filter( lambda e: spec in e['@name'], factory_entries )
                            for spec in entry_names_specs ], [] )
    if not the_entries:
        raise ValueError("Error: There are no configured entries with the specified name")

    return the_entries

def build_records (entries_config):

    downtimes = {"EGI": get_egi(), "OSG": get_osg()}
    report = {'downtimes':{}, 'no downtimes':{}}

    for entry in entries_config:

        entry_name = entry['@name']

        compute_element = entry['@gatekeeper'].split(':')[0]
        target_hosts = {"CE": compute_element}

        storage_element_attrs = filter( lambda e: e['@name'] == 'GLIDEIN_SEs',
                                        entry['attrs']['attr'] )
        if storage_element_attrs:
            storage_element = storage_element_attrs[0]['@value']
            target_hosts["SE"] = storage_element

        record = get_downtime( entry_name, target_hosts, downtimes )
        registered, enforced = is_entry_in_factory_downtime(entry_name)
        key, data = assign_record( record, entry_name, registered, enforced)
        report[key][entry_name] = data

    return report

def assign_record (record, entry_name, registered, enforced):

    text = gen_downtime_message( record, entry_name)

    if record:
        if registered:
            text = "Ongoing {0} downtime is already registered in this factory."
            key = 'no downtimes'
            data = {'text': text.format(entry_name)}
        else:
            command = gen_downtime_command( record, entry_name)
            key = 'downtimes'
            data = {'text': text, 'command': command}
    else:
        key = 'no downtimes'
        if registered:
            if not enforced:
                text = "Finished {0} factory downtime can be removed."
                command = gen_downtime_command( record, entry_name)
                data = {'text': text.format(entry_name), 'command': command}
            else:
                text = "Ongoing enforced {0} factory downtime."
                data = {'text': text.format(entry_name)}
        else:
            data = {'text': text}

    return key, data

def generate_report (records):

    lines = []

    sorter = lambda r: (r[1]['text'], r[0])
    for entry_name, record in sorted(records['no downtimes'].items(), key=sorter):
        lines.append(record['text'])

    for entry_name, record in sorted(records['downtimes'].items(), key=sorter):
        lines.append(record['text'])

    with_commands = {}
    tester = lambda key, rec: 'command' in rec
    for key, record_d in records.items():
        with_commands[key] = filter_dict( tester, record_d)

    if with_commands['downtimes'] or with_commands['no downtimes']:
        lines.append("\n---- ---- ----")
        lines.append("Suggested list of downtime commands:\n")

        for entry_name, record in sorted(with_commands['downtimes'].items(), key=sorter):
            lines.append(record['command'])

        lines.append('\n')

        for entry_name, record in sorted(with_commands['no downtimes'].items(), key=sorter):
            lines.append(record['command'])

    return '\n'.join(lines)

def get_downtime (entry_name, target_hosts, downtimes):

    for federation, records in downtimes.iteritems():
        for host_type, host_name in target_hosts.iteritems():

            record = filter_dict( lambda key, val: key == host_name, records)
            if record:
                record[host_name]['federation'] = federation
                record[host_name]['host_type'] = host_type
                return record

    return None

def gen_downtime_message (downtime_record, entry_name):

    if downtime_record:
        hostname, record = downtime_record.popitem()
        downtime_record[hostname] = record

        message = "%s : This entry IS under downtime:\n" % entry_name
        message += "    Federation: " + record['federation'] + '\n'
        message += " Affected Host: %s (%s)\n" % (hostname, record['host_type'])
        message += "   Description: " + record['description'] + '\n'
        message += "    Start time: " + print_local_dt( record['start']) + '\n'
        message += "      End time: " + print_local_dt( record['end']) + '\n'

    else:
        message = "%s : This entry is NOT under downtime." % entry_name

    return message

def gen_downtime_command (downtime_record, entry_name):

    if downtime_record:
        command_body = """$GLIDEIN_FACTORY_DIR/factory_startup down -entry {entry} -comment '{comment}'"""
        hostname, record = downtime_record.popitem()

        end_time = get_local_dt( record['end'])
        end_time_str = end_time.strftime( "%H:%M %b %d %Y")
        comment = record['description']

        command = command_body.format( entry = entry_name,
                                       comment = comment )
    else:
        command = "entry_nuke {0}; $GLIDEIN_FACTORY_DIR/factory_startup up -entry {0}".format(entry_name)

    return command

def is_entry_in_factory_downtime (entry_name, when=datetime.now(tzutc())):

    downtimes_file = os.getenv('GLIDEIN_FACTORY_DIR') + "/glideinWMS.downtimes"

    registered = False
    enforced = False
    record_lines = []

    with open(downtimes_file) as fd:
        for line in fd:
            if entry_name in line and not line.startswith('#'):
                record_lines.append(line.strip())

    for line in record_lines:
        fields = line.split()

        start = parse_timestamp(fields[0])

        if fields[1] != 'None':
            end = parse_timestamp(fields[1])
        else:
            end = None

        entry = fields[2] # It's equal to entry_name by construction
        frontend = fields[3]
        sec_clas = fields[4]
        comment = ' '.join(fields[5:])

        if when >= start and (end is None or end > when):
            registered = True
            enforced = check_enforced(comment)
            break

    return registered, enforced

def check_enforced (comment):
    return "enforce" in comment

def get_local_dt (utc_dt):
    local_tz = tzl.get_localzone()

    return local_tz.normalize( utc_dt.astimezone( local_tz))

def print_local_dt (utc_dt):

    local_dt = get_local_dt( utc_dt)
    return local_dt.strftime( "%B %d, %Y %H:%M %Z%z")

def filter_dict (test_function, dictionary):

   key_function = lambda e: test_function(e[0], e[1])
   return copy.deepcopy (dict (filter (key_function, dictionary.iteritems())))

def get_user_and_host_names():

    user = getpass.getuser()
    host = socket.gethostname()
    return user, host

def send_email_plain (subject, message):

    user, host = get_user_and_host_names()
    sender = '%s@%s' % (user, host)
    receivers = ['osg-gfactory-reports@physics.ucsd.edu']

    msg = MIMEText (message)

    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = ", ".join(receivers)

    try:
       smtpObj = smtplib.SMTP('localhost')
       smtpObj.sendmail (sender, receivers, msg.as_string())
       print "Successfully sent email"

    except smtplib.SMTPException:
       print "Error: unable to send email"


if __name__ == "__main__":
    sys.exit (main())

