#!/usr/bin/env python2.6

import copy
import os
import optparse
import pytz
import sys
import getpass
import smtplib
import socket
from email.mime.text import MIMEText
from datetime import datetime

import tzlocal as tzl
from dateutil.tz import tzutc
from dateutil.parser import parse as parse_timestamp
from xmltodict import parse as xml_to_dict
from get_grid_downtimes import get_egi, get_osg


def main():

    options, args = parse_command_line()
    if args:
        entry_names_specs = args
    else:
        entry_names_specs = ['all']

    entries = gather_entries( entry_names_specs)
    records = build_records( entries)
    report = generate_report( records, options.verbose)

    print report

    subject = "New entry downtimes updates."
    if options.send:
        send_email_plain( subject, report)
    else:
        if options.ask:
            do_send = raw_input ("Do you want to send the report? ")
            if do_send.lower() in ("y", "ye", "yes", "ok"):
                send_email_plain( subject, report)
            else:
                print "Report not sent."

    return 0

def parse_command_line():

    desc = "Checks GOCDB and OIM for advertised downtimes that are currently not registered on this GlideinWMS factory."

    parser = optparse.OptionParser (description=desc)
    parser.add_option ('-s', '--send', action='store_true', default=False,
                       help="If present, sends the report without asking.")
    parser.add_option ('-a', '--ask', action='store_true', default=False,
                       help="If present, does whether to send email.")
    parser.add_option ('-v', '--verbose', action='store_true', default=False,
                       help="If present, displays even the entries not currently advertised as in downtime.")

    return parser.parse_args()

def gather_entries (entry_names_specs):

    factory_config_file = os.path.join( os.getenv('GLIDEIN_FACTORY_DIR'), "glideinWMS.xml")

    factory_config = xml_to_dict( open( factory_config_file))
    factory_entries = filter( lambda e: e['@enabled'] == 'True',
                              factory_config['glidein']['entries']['entry'] )

    if entry_names_specs[0].lower() in ('*', 'all'):
        the_entries = factory_entries
    else:
        the_entries = sum( [ filter( lambda e: spec in e['@name'], factory_entries )
                            for spec in entry_names_specs ], [] )
    if not the_entries:
        raise ValueError("Error: There are no configured entries with the specified name")

    return the_entries

def build_records (entries_config):

    downtimes = {"EGI": get_egi(), "OSG": get_osg()}
    report = {}

    for entry in entries_config:

        entry_name = entry['@name']

        compute_element = entry['@gatekeeper'].split(':')[0]
        target_hosts = {"CE": compute_element}

        storage_element_attrs = filter( lambda e: e['@name'] == 'GLIDEIN_SEs',
                                        entry['attrs']['attr'] )
        if storage_element_attrs:
            storage_element = storage_element_attrs[0]['@value']
            target_hosts["SE"] = storage_element

        record = get_downtime( entry_name, target_hosts, downtimes )
        registered, enforced = is_entry_in_factory_downtime(entry_name)
        key, data = assign_record( record, entry_name, registered, enforced)

        if key not in report:
            report[key] = {}
        report[key][entry_name] = data

    return report

def assign_record (record, entry_name, registered, enforced):

    if record:
        if registered:
            key, data = 'ongoing', {'complement': ''}
        else:
            text = gen_downtime_message(record, entry_name)
            command = gen_downtime_command( record, entry_name)
            key, data = 'new', {'complement': text, 'command': command}
    else:
        if registered:
            if enforced:
                key, data = 'enforced', {'complement': ''}
            else:
                command = gen_downtime_command( record, entry_name)
                key, data = 'removable', {'complement': '', 'command': command}
        else:
            key, data = 'none', {'complement': ''}

    return key, data

descriptors = {'enforced': "Registered downtimes manually enforced",
               'new': "Newly advertised downtimes",
               'none': "Entries without registered nor advertised downtimes",
               'ongoing': "Ongoing downtimes already registered in this factory",
               'removable': "Registered downtimes that have finished and can be removed" }

def generate_report (records, list_all=True):

    lines = []
    sorter = lambda r: r[0]
    cmd_tester = lambda key, rec: 'command' in rec
    with_commands = {}
    there_are_commands = False
    indentation_step = 2
    indent = 0

    keys = records.keys()
    if not list_all:
        keys.remove('none')

    for status in sorted(keys):
        lines.append( descriptors[status] + ":")
        for entry_name, record in sorted(records[status].items(), key=sorter):
            line = indent_multilines(entry_name,
                                     indent + indentation_step)
            if record['complement']:
                line += ':'
                lines.append(line)
                comp_lines = indent_multilines(record['complement'],
                                               indent + 2*indentation_step)
                lines.append(comp_lines)
                lines.append('')
            else:
                lines.append(line)

        lines.append('')

        with_commands[status] = filter_dict( cmd_tester, records[status])
        there_are_commands |= bool(with_commands[status])

    if there_are_commands:
        lines.append("\n---- ---- ----")
        lines.append("Suggested list of downtime commands:\n")

        for status in keys:
            do_break = False
            for entry_name, record in sorted(with_commands[status].items(), key=sorter):
                lines.append(record['command'])
            else:
                do_break = True

            if do_break: lines.append('')

    return '\n'.join(lines)

def get_downtime (entry_name, target_hosts, downtimes):

    for federation, records in downtimes.iteritems():
        for host_type, host_name in target_hosts.iteritems():

            record = filter_dict( lambda key, val: key == host_name, records)
            if record:
                record[host_name]['federation'] = federation
                record[host_name]['host_type'] = host_type
                return record

    return None

def gen_downtime_message (downtime_record, entry_name):

    if downtime_record:
        hostname, record = downtime_record.popitem()
        downtime_record[hostname] = record

        message =  "    Federation: " + record['federation'] + '\n'
        message += " Affected Host: %s (%s)\n" % (hostname, record['host_type'])
        message += "   Description: " + record['description'] + '\n'
        message += "    Start time: " + print_local_dt( record['start']) + '\n'
        message += "      End time: " + print_local_dt( record['end'])

    else:
        message = "%s : This entry is NOT under downtime." % entry_name

    return message

def gen_downtime_command (downtime_record, entry_name):

    if downtime_record:
        command_body = """$GLIDEIN_FACTORY_DIR/factory_startup down -entry {entry} -comment '{comment}'"""
        hostname, record = downtime_record.popitem()

        end_time = get_local_dt( record['end'])
        end_time_str = end_time.strftime( "%H:%M %b %d %Y")
        comment = record['description'].strip()

        command = command_body.format( entry = entry_name,
                                       comment = comment )
    else:
        command = "entry_nuke {0}; $GLIDEIN_FACTORY_DIR/factory_startup up -entry {0}".format(entry_name)

    return command

def is_entry_in_factory_downtime (entry_name, when=datetime.now(tzutc())):

    downtimes_file = os.getenv('GLIDEIN_FACTORY_DIR') + "/glideinWMS.downtimes"

    registered = False
    enforced = False
    record_lines = []

    with open(downtimes_file) as fd:
        for line in fd:
            if entry_name in line and not line.startswith('#'):
                record_lines.append(line.strip())

    for line in record_lines:
        fields = line.split()

        start = parse_timestamp(fields[0])

        if fields[1] != 'None':
            end = parse_timestamp(fields[1])
        else:
            end = None

        entry = fields[2] # It's equal to entry_name by construction
        frontend = fields[3]
        sec_clas = fields[4]
        comment = ' '.join(fields[5:])

        if when >= start and (end is None or end > when):
            registered = True
            enforced = check_enforced(comment)
            break

    return registered, enforced

def check_enforced (comment):
    return "enforce" in comment.lower()

def get_local_dt (utc_dt):
    local_tz = tzl.get_localzone()

    return local_tz.normalize( utc_dt.astimezone( local_tz))

def print_local_dt (utc_dt):

    local_dt = get_local_dt( utc_dt)
    return local_dt.strftime( "%B %d, %Y %H:%M %Z%z")

def filter_dict (test_function, dictionary):

   key_function = lambda e: test_function(e[0], e[1])
   return copy.deepcopy (dict (filter (key_function, dictionary.iteritems())))

def get_user_and_host_names():

    user = getpass.getuser()
    host = socket.gethostname()
    return user, host

def send_email_plain (subject, message):

    user, host = get_user_and_host_names()
    sender = '%s@%s' % (user, host)
    receivers = ['osg-gfactory-reports@physics.ucsd.edu']

    msg = MIMEText (message)

    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = ", ".join(receivers)

    try:
       smtpObj = smtplib.SMTP('localhost')
       smtpObj.sendmail (sender, receivers, msg.as_string())
       print "Successfully sent email"

    except smtplib.SMTPException:
       print "Error: unable to send email"

def indent_multilines (the_string, indent=0, sub_indent=0):

    # splitlines() takes care of all types of EOL
    lines = the_string.splitlines()
    full_indent = indent + sub_indent

    if sub_indent > 0 and len(lines) > 1:
        line_list = [(' '*indent + lines[0])]
        line_list.extend ([ (' '*full_indent + line) for line in lines[1:] ])
    else:
        line_list = [ (' '*indent + line) for line in lines ]

    return '\n'.join(line_list)


if __name__ == "__main__":
    sys.exit (main())

