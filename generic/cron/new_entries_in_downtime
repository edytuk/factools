#!/usr/bin/env python2.6

import copy
import os
import optparse
import sys
import pytz
import getpass
import smtplib
import socket
from email.mime.text import MIMEText
from datetime import datetime

import tzlocal as tzl
from dateutil.tz import tzutc
from dateutil.parser import parse as parse_timestamp
from xmltodict import parse as xml_to_dict
from get_grid_downtimes import get_egi, get_osg
from jira_recent_report import send_email_plain

def main():

    parser = optparse.OptionParser (description="Checks GOCDB and OIM for advertised downtimes that are currently not registered on this GlideinWMS factory.")
    parser.add_option ('-s', '--send', action='store_true', default=False,
                       help="If present, sends the report without asking.")
    (options, args) = parser.parse_args()

    factory_config_file = os.path.join( os.getenv('GLIDEIN_FACTORY_DIR'), "glideinWMS.xml")

    factory_config = xml_to_dict( open( factory_config_file))
    factory_entries = filter( lambda e: e['@enabled'] == 'True',
                              factory_config['glidein']['entries']['entry'] )

    downtimes = {"EGI": get_egi(), "OSG": get_osg()}
    new_ads = {}

    for entry in factory_entries:

        entry_name = entry['@name']

        compute_element = entry['@gatekeeper'].split(':')[0]
        target_hosts = {"CE": compute_element}

        storage_element_attrs = filter( lambda e: e['@name'] == 'GLIDEIN_SEs',
                                        entry['attrs']['attr'] )
        if storage_element_attrs:
            storage_element = storage_element_attrs[0]['@value']
            target_hosts["SE"] = storage_element

        record = get_downtime( entry_name, target_hosts, downtimes )

        if (record or entry_name not in new_ads) and \
           not is_entry_in_factory_downtime(entry_name):
            text = gen_downtime_message( record, entry_name)
            command = gen_downtime_command( record, entry_name)
            new_ads[entry_name] = {'text': text,
                                  'command': command}

    if new_ads:

        report = []
        for entry_name, record in sorted(new_ads.iteritems()):
            report.append(record['text'])

        report.append("---- ---- ----")
        report.append("Suggested list of downtime commands:\n")
        for entry_name, record in sorted(new_ads.iteritems()):
            report.append(record['command'])

        message = '\n'.join(report)

        print "Report:"
        print message

        subject = "New entry downtimes advertised."
        if options.send:
            send_email_plain( subject, message)
        else:
            do_send = raw_input ("Do you want to send the report? ")
            if do_send.lower() in ("y", "ye", "yes", "ok"):
                send_email_plain( subject, message)
            else:
                print "Report not sent."

    return 0

def get_downtime (entry_name, target_hosts, downtimes):

    for federation, records in downtimes.iteritems():
        for host_type, host_name in target_hosts.iteritems():

            record = filter_dict( lambda key, val: key == host_name, records)
            if record:
                record[host_name]['federation'] = federation
                record[host_name]['host_type'] = host_type
                return record

    return None

def gen_downtime_message (downtime_record, entry_name):

    if downtime_record:
        hostname, record = downtime_record.popitem()
        downtime_record[hostname] = record

        message = "%s :\n" % entry_name
        message += "    Federation: " + record['federation'] + '\n'
        message += " Affected Host: %s (%s)\n" % (hostname, record['host_type'])
        message += "   Description: " + record['description'] + '\n'
        message += "    Start time: " + print_local_dt( record['start']) + '\n'
        message += "      End time: " + print_local_dt( record['end']) + '\n'

    else:
        message = "%s : This entry is NOT under downtime:\n" % entry_name

    return message

def gen_downtime_command (downtime_record, entry_name):

    command_body = """{facdir}/factory_startup down -entry {entry} -comment "{comment}"; echo 'wall "check {entry} downtime"' | at {endtime} """
    factory_dir = os.getenv('GLIDEIN_FACTORY_DIR')
    hostname, record = downtime_record.popitem()

    end_time = get_local_dt( record['end'])
    end_time_str = end_time.strftime( "%H:%M %b %d %Y")
    comment = record['description']

    return command_body.format( facdir = factory_dir, entry = entry_name,
                                comment = comment, endtime = end_time_str )

def is_entry_in_factory_downtime (entry_name, when=None):

    downtimes_file = os.getenv('GLIDEIN_FACTORY_DIR') + "/glideinWMS.downtimes"

    if when is None:
        when = datetime.now(tzutc())

    record_lines = []
    with open(downtimes_file) as fd:
        for line in fd:
            if entry_name in line and not line.startswith('#'):
                record_lines.append(line.strip())

    for line in record_lines:
        fields = line.split()

        start = parse_timestamp(fields[0])

        if fields[1] != 'None':
            end = parse_timestamp(fields[1])
        else:
            end = None

        entry = fields[2] # It's equal to entry_name by construction
        frontend = fields[3]
        sec_clas = fields[4]
        comment = ' '.join(fields[5:])

        if when >= start and (end is None or end > when):
            return True

    return False

def get_local_dt (utc_dt):
    local_tz = tzl.get_localzone()

    return local_tz.normalize( utc_dt.astimezone( local_tz))

def print_local_dt (utc_dt):

    local_dt = get_local_dt( utc_dt)
    return local_dt.strftime( "%B %d, %Y %H:%M %Z%z")

def filter_dict (test_function, dictionary):

   key_function = lambda e: test_function(e[0], e[1])
   return copy.deepcopy (dict (filter (key_function, dictionary.iteritems())))

def get_user_and_host_names():

    user = getpass.getuser()
    host = socket.gethostname()
    return user, host


def send_email_plain (subject, message):

    user, host = get_user_and_host_names()
    sender = '%s@%s' % (user, host)
    receivers = ['osg-gfactory-support@physics.ucsd.edu']

    msg = MIMEText (message)

    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = ", ".join(receivers)

    try:
       smtpObj = smtplib.SMTP('localhost')
       smtpObj.sendmail (sender, receivers, msg.as_string())
       print "Successfully sent email"

    except smtplib.SMTPException:
       print "Error: unable to send email"


if __name__ == "__main__":
    sys.exit (main())

