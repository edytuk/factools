#!/usr/bin/env python2.6

import copy
import os
import optparse
import sys
import pytz
import getpass
import smtplib
import socket
from email.mime.text import MIMEText
from datetime import datetime

import tzlocal as tzl
from dateutil.tz import tzutc
from dateutil.parser import parse as parse_timestamp
from xmltodict import parse as xml_to_dict
from get_grid_downtimes import get_egi, get_osg

def main():

    parser = optparse.OptionParser (description="Checks GOCDB and OIM for advertised downtimes that are currently not registered on this GlideinWMS factory.")
    parser.add_option ('-s', '--send', action='store_true', default=False,
                       help="If present, sends the report without asking.")
    (options, args) = parser.parse_args()

    factory_config_file = os.path.join( os.getenv('GLIDEIN_FACTORY_DIR'), "glideinWMS.xml")

    factory_config = xml_to_dict( open( factory_config_file))
    factory_entries = filter( lambda e: e['@enabled'] == 'True',
                              factory_config['glidein']['entries']['entry'] )

    downtimes = {"EGI": get_egi(), "OSG": get_osg()}
    new_ads = {}

    for entry in factory_entries:

        entry_name = entry['@name']

        compute_element = entry['@gatekeeper'].split(':')[0]
        target_hosts = {"CE": compute_element}

        storage_element_attrs = filter( lambda e: e['@name'] == 'GLIDEIN_SEs',
                                        entry['attrs']['attr'] )
        if storage_element_attrs:
            storage_element = storage_element_attrs[0]['@value']
            target_hosts["SE"] = storage_element

        record = get_downtime( entry_name, target_hosts, downtimes )

        if record and entry_name not in new_ads and \
           not is_entry_in_factory_downtime(entry_name):
            text = gen_downtime_message( record, entry_name)
            command = gen_downtime_command( record, entry_name)
            new_ads[entry_name] = {'text': text,
                                   'command': command}

    if new_ads:
        report = []
        for entry_name, record in sorted(new_ads.iteritems()):
            report.append(record['text'])

        reminders, registers = group_commands_by_endtime(new_ads)
        print reminders
        print registers
        report.append("---- ---- ----")
        report.append("Suggested list of downtime commands:\n")
        report.append(registers)
        report.append(reminders)

        message = '\n'.join(report)
        subject = "New entry downtimes advertised."

    else:
        message = "Debug/Test message."
        subject = "NO new entry downtimes advertised."

    print "Report:"
    print message

    if options.send:
        send_email_plain( subject, message)
    else:
        do_send = raw_input ("Do you want to send the report? ")
        if do_send.lower() in ("y", "ye", "yes", "ok"):
            send_email_plain( subject, message)
        else:
            print "Report not sent."

    return 0

def get_downtime (entry_name, target_hosts, downtimes):

    for federation, records in downtimes.iteritems():
        for host_type, host_name in target_hosts.iteritems():

            record = filter_dict( lambda key, val: key == host_name, records)
            if record:
                record[host_name]['federation'] = federation
                record[host_name]['host_type'] = host_type
                return record

    return None

def gen_downtime_message (in_record, entry_name):

    downtime_record = copy.deepcopy(in_record)
    if downtime_record:
        hostname, record = downtime_record.popitem()

        message = "%s :\n" % entry_name
        message += "    Federation: " + record['federation'] + '\n'
        message += " Affected Host: %s (%s)\n" % (hostname, record['host_type'])
        message += "   Description: " + record['description'] + '\n'
        message += "    Start time: " + print_local_dt( record['start']) + '\n'
        message += "      End time: " + print_local_dt( record['end']) + '\n'

    else:
        message = "%s : This entry is NOT under downtime:\n" % entry_name

    return message

def gen_downtime_command (in_record, entry_name):

    command_body = '$GLIDEIN_FACTORY_DIR/factory_startup down -entry {entry} -comment "{comment}"'

    downtime_record = copy.deepcopy(in_record)
    if downtime_record:
        hostname, record = downtime_record.popitem()

        end_time = get_local_dt( record['end'])
        comment = record['description']

        return [command_body.format( entry = entry_name, comment = comment),
                end_time]
    return []

def group_commands_by_endtime (report_dict):

    reminder_tpl = """echo 'wall "Check {entry_spec} downtime"' | at {endtime}"""

    grouped = {}
    for entry_name, record in sorted(report_dict.iteritems()):
        command_spec = record['command']
        if command_spec:
            register_dt, end_time = command_spec
            if end_time not in grouped:
                grouped[end_time] = {'registrars': [], 'entries': []}
            grouped[end_time]['registrars'].append( register_dt)
            grouped[end_time]['entries'].append( entry_name)

    reminders = []
    registers = []
    for end_time, group in sorted(grouped.iteritems()):
        reminder_cmd = reminder_tpl.format( entry_spec = ', '.join(group['entries']),
                                            endtime = end_time )
        register_cmds = '\n'.join(group['registrars'])

        reminders.append(reminder_cmd)
        registers.append(register_cmds)

    return reminders, registers

def is_entry_in_factory_downtime (entry_name, when=None):

    downtimes_file = os.getenv('GLIDEIN_FACTORY_DIR') + "/glideinWMS.downtimes"

    if when is None:
        when = datetime.now(tzutc())

    record_lines = []
    with open(downtimes_file) as fd:
        for line in fd:
            if entry_name in line and not line.startswith('#'):
                record_lines.append(line.strip())

    for line in record_lines:
        fields = line.split()

        start = parse_timestamp(fields[0])

        if fields[1] != 'None':
            end = parse_timestamp(fields[1])
        else:
            end = None

        entry = fields[2] # It's equal to entry_name by construction
        frontend = fields[3]
        sec_class = fields[4]
        comment = ' '.join(fields[5:])

        if when >= start and (end is None or end > when):
            return True

    return False

def get_local_dt (utc_dt):
    local_tz = tzl.get_localzone()

    return local_tz.normalize( utc_dt.astimezone( local_tz))

def print_local_dt (utc_dt):

    local_dt = get_local_dt( utc_dt)
    return local_dt.strftime( "%B %d, %Y %H:%M %Z%z")

def filter_dict (test_function, dictionary):

   key_function = lambda e: test_function(e[0], e[1])
   return copy.deepcopy (dict (filter (key_function, dictionary.iteritems())))

def get_user_and_host_names():

    user = getpass.getuser()
    host = socket.gethostname()
    return user, host

def send_email_plain (subject, message):

    user, host = get_user_and_host_names()
    sender = '%s@%s' % (user, host)
    receivers = ['osg-gfactory-reports@physics.ucsd.edu']

    msg = MIMEText (message)

    msg['Subject'] = subject
    msg['From'] = sender
    msg['To'] = ", ".join(receivers)

    try:
       smtpObj = smtplib.SMTP('localhost')
       smtpObj.sendmail (sender, receivers, msg.as_string())
       print "Successfully sent email"

    except smtplib.SMTPException:
       print "Error: unable to send email"


if __name__ == "__main__":
    sys.exit (main())

